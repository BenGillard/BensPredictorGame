---
title: "Euro 2021 Predictor"
knit: (function(input_file, encoding) {
  out_dir <- 'docs';
  rmarkdown::render(input_file,
 encoding=encoding,
 output_file=file.path(dirname(input_file), out_dir, 'index.html'))})
author: "Gillard BT"
date: "Updated: `r Sys.Date()`"
output: 
  html_document: 
    toc: yes
    toc_depth: 4
    theme: cerulean
---

<style>
body {
text-align: justify}
</style>

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, tidy = TRUE)
```

```{r FormatData, message=FALSE}
#read in real life results
TrueResults<- readxl::read_excel("EuroPredictorTrueResults.xlsm")
TrueResults<- TrueResults[7:42, 3:6]
colnames(TrueResults)<- c("Home", "HomeScore", "AwayScore", "Away")
TrueResults<- cbind(TrueResults, Result = ifelse(TrueResults$HomeScore == TrueResults$AwayScore, "Draw", ifelse(TrueResults$HomeScore > TrueResults$AwayScore, TrueResults$Home, TrueResults$Away))) #result information
AllPreds<- list(CorrectResults = TrueResults) #seed list so player predictions can be added

#get predictions from every player (use loop calling all files in Entries directory)
entries<- list.files("Entries/", full.names = TRUE)
for(file in entries){
predictionsRoot<- readxl::read_excel(file) #change to file
player<- gsub(" ", "", as.character(predictionsRoot[47,2]),  fixed = TRUE)
predictions<- predictionsRoot[7:42, 3:6]
colnames(predictions)<- c("Home", "HomeScore", "AwayScore", "Away")
predictions<- cbind(predictions, Result = ifelse(predictions$HomeScore == predictions$AwayScore, "Draw", ifelse(predictions$HomeScore > predictions$AwayScore, predictions$Home, predictions$Away))) #result information
AllPreds<- append(AllPreds, list(predictions)) #append player's predictions to list seeded by correct results
names(AllPreds)[length(AllPreds)]<- player #rename list with player name
}

saveRDS(object = AllPreds, file = "AllResults.RDS") #save object so this chunk only needs to be run if new players submit results
```


```{r ImportResults}
Results<- readRDS(file = "AllResults.RDS")

#loop over each row?
  #cbind points to each player? with lapply?
invisible(unlist(lapply(names(Results[2:length(Results)]), function(x) identical(Results[[1]][[1]], Results[[x]][[1]])))) #check format is identical by checking home team names

#successful points vector for one player (first player in the Results list object)
#unlist(lapply(1:nrow(Results$CorrectResults[!is.na(Results$CorrectResults$HomeScore),]), function(row) ifelse(identical(Results[[1]][[row,2]], Results[[2]][[row,2]]) & identical(Results[[1]][[row,3]], Results[[2]][[row,3]]), 3, ifelse(identical(Results[[1]][[row,5]], Results[[2]][[row,5]]), 1, 0))))

Scores<- lapply(names(Results[2:length(Results)]), function(x) unlist(lapply(1:nrow(Results$CorrectResults[!is.na(Results$CorrectResults$HomeScore),]), function(row) ifelse(identical(Results[[1]][[row,2]], Results[[x]][[row,2]]) & identical(Results[[1]][[row,3]], Results[[x]][[row,3]]), 3, ifelse(identical(Results[[1]][[row,5]], Results[[x]][[row,5]]), 1, 0)))))

names(Scores)<- names(Results[2:length(Results)])
```

**Welcome to the EURO 2020 Predictor Championship!** The aim of the game is simple, predict the scores for all of the group stage games at this year's tournament. Each correct *score* earns 3 points. Each correct *result* earns 1 point.

We have `r length(Results)-1` players involved so we have a healthy kitty to pay out for the top 3 players. £`r (length(Results)-1)*5*0.5` goes to the top dog. £`r (length(Results)-1)*5*0.3` for the top loser. And £`r (length(Results)-1)*5*0.2` for the best of the rest.

#Leaderboard

```{r Leaderboard, message=FALSE}
LeaderBoard<- data.frame(Player = names(Scores), Points = unlist(lapply(Scores, sum)), CorrectScore = unlist(lapply(Scores, function(x) sum(x == 3))), CorrectResult = unlist(lapply(Scores, function(x) sum(x == 1))), row.names = NULL)

library(kableExtra)
kbl(LeaderBoard[order(LeaderBoard$Points, LeaderBoard$CorrectScore, decreasing = TRUE),], caption = "Table of Champions", align = "l", row.names = FALSE) %>% kable_classic() %>%  row_spec(1, bold = T, background = "#c9b037") %>% row_spec(2, bold = T, background = "#b4b4b4") %>% row_spec(3, bold = T, background = "#ad8a56")
```

> When 2 players have the same points tally, correct scores are taken into account. If players are still equal, the tie break question "How many total goals (including knockout games) will England score at Euro 2020?" will come into play. Closest wins.

##England Goals

Tracks the tie break question of how many goals England will score. The TrueGoals are updated after every England game.

```{r englandGoals, message=FALSE}
TrueGoals<- as.numeric(readxl::read_excel("EuroPredictorTrueResults.xlsm")[44,7])
AllGoals<- list(TrueGoals = TrueGoals) #seed list so player predictions can be added
for(file in entries){
predictionsRoot<- readxl::read_excel(file) #change to file
player<- gsub(" ", "", as.character(predictionsRoot[47,2]),  fixed = TRUE)
EngGoals<- as.numeric(predictionsRoot[44,7])
#result information
AllGoals<- append(AllGoals, list(EngGoals)) #append player's predictions to list seeded by correct results
names(AllGoals)[length(AllGoals)]<- player #rename list with player name
}
barplot(unlist(AllGoals), main = "Tie Breaker: England Goals scored", col = c("red", "white"), las = 2, cex.names = 0.7)
abline(h = AllGoals$TrueGoals, lty = 2, col = "red")
```

#Hypothetical Euros

Just a couple of plots showing who we, as a group of Mystic Megs, predict will be the winners and losers in the group stage.

```{r IfwePredicted, fig.show='hold', out.width='50%'}
WinnerCount<- sapply(names(Results[2:length(Results)]), function(x) summary(as.factor(Results[[x]][["Result"]])), USE.NAMES = TRUE)

#top predicted result
barplot(table(unlist(lapply(names(WinnerCount), function(x) names(WinnerCount[[x]])[which(WinnerCount[[x]] == max(WinnerCount[[x]]))]))), horiz = TRUE, las = 1, cex.names = 0.5, col = viridis::rocket(10), main = "Overall most predicted results", xlab = "Number of wins predicted", xlim=range(pretty(c(0, 10))))

#bottom predicted result
barplot(table(unlist(lapply(names(WinnerCount), function(x) names(WinnerCount[[x]])[which(WinnerCount[[x]] == min(WinnerCount[[x]]))]))), horiz = TRUE, las = 1, cex.names = 0.5, col = viridis::magma(10), main = "Overall least predicted results", xlab = "Number of wins predicted", xlim=range(pretty(c(0, 3), n = 3)))
```

And looking at how many times everyone has picked a draw, England win, or Scotland win (more specifics available on request).

```{r specificTeams, fig.show='hold'}
#draws
barplot(sapply(names(Results[1:length(Results)]), function(x) sum(Results[[x]][["Result"]] == "Draw"), USE.NAMES = TRUE), main = "Predicted number of Draws", col = viridis::turbo(length(Results)), las = 2, cex.names = 0.7)
abline(h = sum(Results$CorrectResults[["Result"]] == "Draw"), lty = 2, col = "black")

#england wins
barplot(sapply(names(Results[1:length(Results)]), function(x) sum(Results[[x]][["Result"]] == "England"), USE.NAMES = TRUE), main = "Predicted number of England Wins", col = c("red", "white"), las = 2, cex.names = 0.7)
abline(h = sum(Results$CorrectResults[["Result"]] == "England"), lty = 2, col = "black")

#scotland wins
barplot(sapply(names(Results[1:length(Results)]), function(x) sum(Results[[x]][["Result"]] == "Scotland"), USE.NAMES = TRUE), main = "Predicted number of Scotland Wins", col = c("blue", "white"), las = 2, cex.names = 0.7)
abline(h = sum(Results$CorrectResults[["Result"]] == "Scotland"), lty = 2, col = "black")
```

